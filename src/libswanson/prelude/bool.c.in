/* -*- coding: utf-8 -*-
 * ----------------------------------------------------------------------
 * Copyright Â© 2012, RedJack, LLC.
 * All rights reserved.
 *
 * Please see the LICENSE.txt file in this distribution for license
 * details.
 * ----------------------------------------------------------------------
 */

#include <assert.h>
#include <stdlib.h>

#include <libcork/core.h>
#include <libcork/helpers/errors.h>
#include <libcork/helpers/gc.h>

#include "swanson/helpers.h"
#include "swanson/metamodel.h"
#include "swanson/prelude.h"
#include "swanson/state.h"


/*-----------------------------------------------------------------------
 * swan_bool
 */

_class_(swan_bool);
_method_(swan_bool__not);
_method_(swan_bool__and);
_method_(swan_bool__or);
_method_(swan_bool__xor);
_method_(swan_bool__tostring);


static struct swan_bool  swan_bool__false = { { &swan_bool__class }, false };
static struct swan_bool  swan_bool__true = { { &swan_bool__class }, true };

struct swan_object *
swan_bool_false(void)
{
    return &swan_bool__false.parent;
}

struct swan_object *
swan_bool_true(void)
{
    return &swan_bool__true.parent;
}

_eval_(swan_bool__not) {
    struct swan_bool  *self;
    _ensure_param_count_(1);
    _ensure_result_count_(1);
    _ensure_class_(self, params[0], swan_bool);
    return swan_bool_new(!self->value);
}

_eval_(swan_bool__and) {
    struct swan_bool  *lhs;
    struct swan_bool  *rhs;
    _ensure_param_count_(2);
    _ensure_result_count_(1);
    _ensure_class_(lhs, params[0], swan_bool);
    _ensure_class_(rhs, params[1], swan_bool);
    return swan_bool_new(lhs->value && rhs->value);
}

_eval_(swan_bool__or) {
    struct swan_bool  *lhs;
    struct swan_bool  *rhs;
    _ensure_param_count_(2);
    _ensure_result_count_(1);
    _ensure_class_(lhs, params[0], swan_bool);
    _ensure_class_(rhs, params[1], swan_bool);
    return swan_bool_new(lhs->value || rhs->value);
}

_eval_(swan_bool__xor) {
    struct swan_bool  *lhs;
    struct swan_bool  *rhs;
    _ensure_param_count_(2);
    _ensure_result_count_(1);
    _ensure_class_(lhs, params[0], swan_bool);
    _ensure_class_(rhs, params[1], swan_bool);
    return swan_bool_new(lhs->value ^ rhs->value);
}

_eval_(swan_bool__tostring) {
    struct swan_bool  *self;
    struct swan_static_string  *result;
    _ensure_param_count_(1);
    _ensure_result_count_(0);
    _ensure_class_(self, params[0], swan_bool);
    result = swan_static_string_new(s, self->value? "true": "false");
    return &result->parent;
}

_get_method_(swan_bool) {
    _return_op_(swan_bool, not, "!");
    _return_op_(swan_bool, and, "&&");
    _return_op_(swan_bool, or, "||");
    _return_op_(swan_bool, xor, "^");
    _return_method_(swan_bool, tostring);
    swan_metamodel_undefined(vc->name, name);
    return NULL;
}
